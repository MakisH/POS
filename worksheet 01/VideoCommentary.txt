4.1.2: Nathan

"In the video, make sure to mention which functions represented most of the execution time of the benchmark. Enumerate the functions that make together 80% or more of the execution time."

The function CalcHourglassControlForElems() takes 72% of the execution time, and the function CalcKinematicsForElems() takes 22% of the time.  Combined, they take up 94% of the execution time. 

4.2.2: Chip
1. where to find

2. it is not practical to test all the flags.  In this case, a step by step 
perfomance optimization is most practical.  First run w/o any compiler flags.
Then, impliment general optimization step by step with the flag -01 -02 -03.
Intel then recomends initializing processor specific optimizations, namely
"-xHost". Then apply code specific geusses one by one to test for performace 
optimizations, and impliment only those where a higher performace is achieved.

2. In our cases these flags were -O3 -march="native" -funroll-loops -floop-block"
for gcc and -03 -xHost -unroll for icc
4.3.2: Makis
5.1.2: Chip

In this case linear scalability was not achieved but rather relative speedup 
decread as the number of threads increased

5.2.2: Nathan

LULESH only accepts cubes of integers (i.e. That means, 1, 8, 27, etc.) as process counts, and SuperMUC thin nodes have 16 cores total.




5.3.2: Makis
